

Java 8 Streams: Transform, Filter, and Reduce Your Way to Cleaner Code!
Streams enable functional-style programming in Java, allowing us to write cleaner, more readable, and more efficient code. 

💡 Key Methods in Streams :-
 1. map():
Transforms each element in a stream.
Example: Convert a list of names to uppercase.

List<String> names = List.of("John", "Jane");
List<String> upperNames = names.stream()
 .map(String::toUpperCase)
 .toList();

 2. filter():
Filters elements based on a condition.
Example: Get even numbers from a list.

List<Integer> numbers = List.of(1, 2, 3, 4);
List<Integer> evens = numbers.stream()
 .filter(n -> n % 2 == 0)
 .toList();

 3. flatMap():
Flattens nested structures like lists of lists into a single stream.
Example: Combine lists into one.

List<List<Integer>> listOfLists = List.of(List.of(1, 2), List.of(3, 4));
List<Integer> flatList = listOfLists.stream()
 .flatMap(List::stream)
 .toList();

 4. reduce():
Reduces elements to a single value using an accumulator.
Example: Sum a list of numbers.

List<Integer> numbers = List.of(1, 2, 3, 4);
int sum = numbers.stream()
 .reduce(0, Integer::sum);

 5. forEach():
Iterates through elements for side-effects (e.g., printing).
Example: Print all elements in a list.

List<String> names = List.of("John", "Jane");
names.stream().forEach(System.out::println);

🌟 Why Use Streams?
 • Readable Code: Concise and expressive.
 • Efficient Processing: Streams are lazy; operations are only executed when needed.
 • Parallel Processing: With .parallelStream(), you can easily process data in parallel.
 
 ==================================
 inject a Prototype-scoped bean into a Singleton-scoped bean in Spring
1. How to use Lambda expressions and Stream API in Java? 
Can you write a simple example where you filter a list of numbers and find the sum of even numbers using Java Streams?
2. What is the difference between synchronized and volatile in Java? Can you give an example of when each would be used?
3. Can you explain how Spring Boot's auto-configuration mechanism works? How does it help developers to quickly set up an application?
=>a.Spring Boot Starters: 
	-Spring Boot provides starter dependencies (e.g., spring-boot-starter-web, spring-boot-starter-data-jpa) that bundle commonly used libraries for specific functionalities.
	-When you include a starter in your pom.xml or build.gradle, Spring Boot automatically assumes what you might want to configure based on these dependencies.
b.@EnableAutoConfiguration and @SpringBootApplication:
	-The @EnableAutoConfiguration part scans the classpath for available libraries and configures the application based on their presence.
c.Conditional Configuration:
	-Spring Boot's auto-configuration uses conditional annotations (e.g., @ConditionalOnClass, @ConditionalOnMissingBean) to determine whether certain configurations should be applied.
		-If a DataSource bean is not already defined but a HikariCP library is available, Spring Boot configures a default DataSource.
d.Default Properties:
	-Spring Boot provides sensible default configurations for many components.
	-If using an embedded database like H2, Spring Boot sets it up automatically.
Default server settings are applied (e.g., running on port 8080).
e.Customizing Configuration:
	-Developers can override auto-configuration defaults by:
	-Providing custom settings in the application.properties or application.yml file.
f.Auto-Configuration Classes:
	-Spring Boot uses specific configuration classes for auto-configuration, which are listed in the spring.factories file under META-INF/ in the spring-boot-autoconfigure JAR.

4. Can you explain the concept of Dependency Injection (DI) in Spring? How have you used DI in your Spring Boot applications? Can you give an example of constructor-based DI and setter-based DI?
5. How can you expose RESTful services in Spring Boot? Can you walk me through creating a simple REST API with a GET and POST method?
6. How to secure a Spring Boot application? Can you explain how you would use Spring Security for user authentication and authorization? Can you describe an example where you configured role-based access control?
7. How to deploy a Spring Boot application to an AWS EC2 instance? 
8. Can you explain how AWS S3 works? How to use it in a Spring Boot application to store and retrieve files?
9. Can you explain how Maven manages the build lifecycle of a project? What are the main phases of the Maven lifecycle, and how have you used them in your projects?
10. How does Maven handle project dependencies? Can you explain how you manage version conflicts with Maven?
11. What are Maven profiles and plugins? How do you use them to customize builds for different environments or purposes?
12. How to write unit tests in Java using JUnit? Can you provide an example of a simple unit test for a Spring Boot service method?
13. What is Mockito used for, and how would you use it to mock a service in a Spring Boot application? Can you show an example where you mock an external service call in a unit test?
14. Can you explain Test-Driven Development (TDD)? How have you applied TDD in your Spring Boot projects, and what challenges did you face while writing tests before the implementation?

========================

#SDET
1. Reverse a String:
 Write a Java program to reverse a given string.
2. Find the Largest Element in an Array:
 Find and print the largest element in an array.
3. Check for Palindrome:
 Determine if a given string is a palindrome (reads the same backward as forward).
4. Factorial Calculation:
 Write a function to calculate the factorial of a number.
5. Fibonacci Series:
 Generate the first n numbers in the Fibonacci sequence.
6. Check for Prime Number:
 Write a program to check if a given number is prime.
7. String Anagrams:
 Determine if two strings are anagrams of each other.
8. Array Sorting:
 Implement sorting algorithms like bubble sort, merge sort, or quicksort.
9. Binary Search:
 Implement a binary search algorithm to find an element in a sorted array.
10. Duplicate Elements in an Array:
 Find and print duplicate elements in an array.
11. Linked List Reversal:
 Reverse a singly-linked list.
12. Matrix Operations:
 Perform matrix operations like addition, multiplication, or transpose.
13. Implement a Stack:
 Create a stack data structure and implement basic operations (push, pop).
14. Implement a Queue:
 Create a queue data structure and implement basic operations (enqueue, dequeue).

15. Inheritance and Polymorphism:
 Implement a class hierarchy with inheritance and demonstrate polymorphism.
16. Exception Handling:
 Write code that demonstrates the use of try-catch blocks to handle exceptions.
17. File I/O:
 Read from and write to a file using Java's file I/O capabilities.
18. Multithreading:
 Create a simple multithreaded program and demonstrate thread synchronization.
19. Lambda Expressions:
 Use lambda expressions to implement functional interfaces.
20. Recursive Algorithms:
 Solve a problem using recursion, such as computing the factorial or Fibonacci sequence.
 
===================================

// SpringBoot

1. In how many ways we can return the data in springboot rest api.
2. Which framework used to create web and restful applications in spring that can return JSON and XML file ?
3. Which is more secure ? SOAP or REST ? Why ?
4. What are different ways to configure a class as Spring Bean ?
5. Explain the role of the Tomcat server in the Spring Boot Application
6. Which classe responsible for handling incoming HTTP requests and returning an appropriate response ?
7. Why do we need springBoot auto configuration ?
8. About Metadata in Spring Framework?
9. What are the limitations of Autowiring ?
10. Can you inject null and empty string values in Spring? If yes, how ?

PHASE 1 - Basics

• Creating a spring boot project using spring initializr
• Maven and gradle build tools
• Annotations
• Profiles and environment-specific configurations
• @getmapping, @postmapping, @putmapping, @deletemapping
• Handling path variables and request parameters
• Setting up database connection (h2, mysql, postgresql)
• Using jparepository and crudrepository
• Introduction to spring boot devtools
• Enabling hot reloading
• Spring batch, scheduling and cron expressions


PHASE 2 - Intermediate

• Using @controlleradvice and @exceptionhandler
• Custom error responses and exception classes
• Global exception handling
• Basic authentication
• Configuring security for apis
• Implementing jwt (json web tokens) for stateless authentication
• Introduction to hateoas
• Versioning rest apis (uri, parameter, headers)
• Unit testing with junit and mockito
• Writing integration tests with spring boot test
• Testing restful services with mockmvc
• Exploring actuator endpoints
• Creating custom health indicators


PHASE 3 - Advanced

• Using @profile annotation
• Configuring environment-specific beans
• Switching profiles for different environments
• Setting up a spring cloud project
• Key components of spring cloud
• Setting up eureka server
• Registering microservices with eureka
• Service discovery in action
• Introduction to api gateway
• Setting up spring cloud gateway
• Configuring routes and filters
• Setting up spring cloud config server
• Managing configuration in a centralized repository
• Configuring spring boot applications to use config server


PHASE 4 - Microservices

• Introduction to inter-service communication
• Using rest template for synchronous communication
• Using feign client for simplified service calls
• Setting up resilience4j
• Configuring circuit breakers, retry in microservices
• Introduction to distributed tracing
//Multithreading interview question

//==========================================

 Top 5 Essential Spring Boot Interview Questions & Answers 

1. What is Spring Boot and why is it used?
Spring Boot simplifies the development of Spring-based applications by providing production-ready defaults and reducing configuration. 
It allows faster development with minimal setup.

2. What are the advantages of using Spring Boot?
Auto-Configuration: Automatically configures your app based on the project’s dependencies.
Embedded Servers: Supports embedded web servers like Tomcat, Jetty, and Undertow.
Production-Ready: Includes features like health checks, metrics, and monitoring.
Minimal Configuration: Reduces boilerplate code, allowing faster development.

3. What is the use of @SpringBootApplication annotation?
This annotation combines @Configuration, @EnableAutoConfiguration, and @ComponentScan, 
simplifying application setup and reducing the need for explicit configuration.

4. What is Spring Boot Actuator?
Spring Boot Actuator offers production-ready features like health checks, metrics, and monitoring, 
allowing you to track your app's performance and health.

5. How can you create RESTful services in Spring Boot?
Use the @RestController annotation and define endpoints with @GetMapping, @PostMapping, etc.,
 to create REST APIs easily and effectively in Spring Boot.

============================================

✅𝟒𝟎 𝐄𝐬𝐬𝐞𝐧𝐭𝐢𝐚𝐥 𝐒𝐩𝐫𝐢𝐧𝐠 𝐁𝐨𝐨𝐭 𝐀𝐧𝐧𝐨𝐭𝐚𝐭𝐢𝐨𝐧𝐬 𝐟𝐨𝐫 𝐃𝐞𝐯𝐞𝐥𝐨𝐩𝐞𝐫s

1. @Required: Ensures a bean property must be set.
2. @Autowired: Automatically injects dependencies.
3. @Configuration: Declares @Bean methods in a class.
4. @ComponentScan: Configures component scanning.
5. @Bean: Produces a managed Spring bean.
6. @Qualifier: Specifies bean injection options.
7. @Lazy: Delays bean initialization.
8. @Value: Injects a property value.
9. @Component: Marks a Spring component.
10. @Controller: Handles MVC views.
11. @Service: Marks service layer components.
12. @Repository: Marks DAOs with exception translation.
13. @EnableAutoConfiguration: Enables auto-configuration.
14. @SpringBootApplication: Configures Spring Boot app.
15. @RequestMapping: Maps HTTP methods.
16. @GetMapping: Handles HTTP GET requests.
17. @PostMapping: Maps HTTP POST requests.
18. @PutMapping: Maps HTTP PUT requests.
19. @DeleteMapping: Maps HTTP DELETE requests.
20. @PatchMapping: Maps HTTP PATCH requests.
21. @RequestBody: Binds HTTP request body.
22. @ResponseBody: Binds HTTP response body.
23. @PathVariable: Extracts URI values.
24. @RequestParam: Extracts query parameters.
25. @RequestHeader: Extracts header values.
26. @RestController: Combines @Controller and @ResponseBody.
27. @RequestAttribute: Binds request attributes.
28. @CookieValue: Binds HTTP cookie values.
29. @CrossOrigin: Enables CORS.
30. @Profile: Specifies bean profiles.
31. @Scope: Defines bean scopes.
32. @Conditional: Registers beans conditionally.
33. @Primary: Sets primary autowired beans.
34. @PropertySource: Adds PropertySource to Environment.
35. @EnableAsync: Enables asynchronous methods.
36. @EnableScheduling: Enables scheduled tasks.
37. @EnableCaching: Enables caching.
38. @RestControllerAdvice: Specializes @ControllerAdvice for REST.
39. @JsonIgnoreProperties: Ignores JSON properties.
40. @JsonProperty: Maps JSON properties to Java fields.

==========================================

🚀 Spring Boot Caching

In today’s fast-paced development world, application performance is critical. 
One way to enhance performance is by leveraging Spring Boot Caching, which simplifies adding a caching layer to your application.

Let me break down the key caching annotations Spring Boot provides:

📌 @EnableCaching
Activates caching for your Spring Boot application.

📌 @Cacheable
Caches the result of a method. If the method is called with the same parameters, the cached result is returned, saving processing time.

@Cacheable(value = "books", key = "#id", unless = "#result == null")
public Book getBookById(Long id) {
 return bookRepository.findById(id);
}

📌 @CachePut
Updates the cache with a new value whenever the annotated method is invoked.

@CachePut(value = "books", key = "#book.id")
public Book updateBook(Book book) {
 return bookRepository.save(book);
}

📌 @CacheEvict
Removes entries from the cache to keep data consistent.

@CacheEvict(value = "books", key = "#id")
public void deleteBookById(Long id) {
 bookRepository.deleteById(id);
}

📌 @Caching
Combines multiple cache operations for complex scenarios.


@Caching(
 put = { @CachePut(value = "books", key = "#book.id") },
 evict = { @CacheEvict(value = "allBooks", allEntries = true) }
)
public Book saveBook(Book book) {
 return bookRepository.save(book);
}

📌 @CacheConfig
Reduces redundancy by defining common cache configurations at the class level.

@CacheConfig(cacheNames = "books")
public class BookService {
 @Cacheable(key = "#id")
 public Book getBookById(Long id) {
 return bookRepository.findById(id);
 }
}


1️⃣ Add the Spring Boot cache dependency:

<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

2️⃣ Enable caching:

@SpringBootApplication
@EnableCaching
public class Application {
 public static void main(String[] args) {
 SpringApplication.run(Application.class, args);
 }
}

3️⃣ Configure your caching provider (e.g., EhCache, Caffeine, Redis).

By leveraging these annotations, you can seamlessly integrate caching into your Spring Boot application 
and improve performance by reducing redundant computations or database hits.

======================================

𝐍𝐞𝐬𝐭𝐞𝐝 𝐂𝐥𝐚𝐬𝐬𝐞𝐬 𝐢𝐧 𝐉𝐚𝐯𝐚

In Java, a nested class is a class defined within another class. There are 𝐟𝐨𝐮𝐫 types of nested classes:

1) 𝐌𝐞𝐦𝐛𝐞𝐫 𝐈𝐧𝐧𝐞𝐫 𝐂𝐥𝐚𝐬𝐬: A member inner class is a class defined at the same level as other class members. To instantiate it, we must first instantiate the outer class. Member inner classes have access to all members of the outer class, including 𝐩𝐫𝐢𝐯𝐚𝐭𝐞 𝐦𝐞𝐦𝐛𝐞𝐫𝐬.

2) 𝐋𝐨𝐜𝐚𝐥 𝐈𝐧𝐧𝐞𝐫 𝐂𝐥𝐚𝐬𝐬: A local inner class is a class defined within a method, similar to a local variable. Its scope is limited to the method, and it has access to all members of the enclosing class. However, it can only access 𝐟𝐢𝐧𝐚𝐥 or 𝐞𝐟𝐟𝐞𝐜𝐭𝐢𝐯𝐞𝐥𝐲 𝐟𝐢𝐧𝐚𝐥 local variables of the enclosing method.

3) 𝐀𝐧𝐨𝐧𝐲𝐦𝐨𝐮𝐬 𝐈𝐧𝐧𝐞𝐫 𝐂𝐥𝐚𝐬𝐬: Anonymous inner classes are inner classes with no name and are declared and instantiated in a single expression. They can extend a class or implement an interface but are limited to one superclass or one interface. Note that 𝐥𝐚𝐦𝐛𝐝𝐚𝐬 introduced in Java 8 serve similar use cases for functional interfaces.

4) 𝐒𝐭𝐚𝐭𝐢𝐜 𝐍𝐞𝐬𝐭𝐞𝐝 𝐂𝐥𝐚𝐬𝐬: Static nested classes are defined with the 𝐬𝐭𝐚𝐭𝐢𝐜 keyword at the same level as other class members. They can be instantiated without an object of the enclosing class and can only access static members of the outer class.

======================================

𝗙𝗿𝗲𝗲 𝗞𝗮𝗳𝗸𝗮 𝗥𝗲𝘀𝗼𝘂𝗿𝗰𝗲𝘀: 

1. Apache Kafka crash course with Spring Boot 3.0.x by Java Techie
 - https://lnkd.in/dP3wziT6
2. Apache Kafka with Spring Boot crash course by Daily Code Buffer
 - https://lnkd.in/dhz-kJB5
3. All about Kafka by Learning Tutorial
 - https://lnkd.in/drZ_hbq2
4. Kafka Tutorial by Intellipaat
 - https://lnkd.in/dSr77EcE
5. Kafka crash course by Hussein Nasser 
 - https://lnkd.in/dDND2e6z

𝗛𝗼𝘄 𝗞𝗮𝗳𝗸𝗮 𝗶𝗺𝗽𝗹𝗲𝗺𝗲𝗻𝘁𝗲𝗱 𝗮𝘁 𝗧𝗲𝗰𝗵 𝗚𝗶𝗮𝗻𝘁𝘀:

1. LinkedIn's Kafka Journey 
 - https://lnkd.in/d_QijMDk
2. Pinterest's Kafka at Scale
 - https://lnkd.in/dvV-8hun
3. Why Trello Chose Kafka
 - https://lnkd.in/gJhvX-dg
4. Salesforce's Kafka-Inspired Architecture
 - https://lnkd.in/gBH3bwGq
5. NYT's Publishing with Kafka
 - https://lnkd.in/gqcwF_zP
6. Yelp's Billions of Messages
 - https://lnkd.in/g7_fcfB7
7. Criteo's Kafka Upgrade 
 - https://lnkd.in/gwGx8wvq
8. Shopify's Kafka on Kubernetes
 - https://lnkd.in/gSdHqzb4
9. Yelp's Zero-Downtime Zookeeper Migration
 - https://lnkd.in/gHdphiQY
10. Uber's Kafka Reprocessing
 - https://lnkd.in/gti2xZuR
 - https://lnkd.in/gDF2S-vX
11. Dropbox's Kafka Throughput Limits
 - https://lnkd.in/gqpwjHzv
12. Walmart's Cost Orchestration
 - https://lnkd.in/gdtc5Az9
13. PayPal's Kafka Scaling
 - https://lnkd.in/gSxAVa89

𝗞𝗮𝗳𝗸𝗮 𝗜𝗻𝘁𝗲𝗿𝘃𝗶𝗲𝘄 𝗤𝘂𝗲𝘀𝘁𝗶𝗼𝗻𝘀:

Basic Level:
1. What is Apache Kafka, and what are its core components?
2. Explain the difference between a topic, partition, and segment.
3. How does Kafka ensure message ordering?
4. What is a consumer group in Kafka?

Intermediate Level:
5. How does Kafka achieve fault tolerance? 
6. Explain Kafka's partitioning strategy and how it impacts performance.
7. Describe Kafka's consumer offset management.

Advanced Level:
8. Explain the concept of exactly-once semantics (EOS) in Kafka.
9. How would you monitor and optimize Kafka performance in a production environment? 
10. How would you design a Kafka-based system to guarantee data consistency in the event of node failures?

============================
20 recently asked 𝗞𝗔𝗙𝗞𝗔 interview questions.

- How do you create a topic in Kafka using the Confluent CLI?
- Explain the role of the Schema Registry in Kafka.
- How do you register a new schema in the Schema Registry?
- What is the importance of key-value messages in Kafka?
- Describe a scenario where using a random key for messages is beneficial.
- Provide an example where using a constant key for messages is necessary.
- Write a simple Kafka producer code that sends JSON messages to a topic.
- How do you serialize a custom object before sending it to a Kafka topic?
- Describe how you can handle serialization errors in Kafka producers.
- Write a Kafka consumer code that reads messages from a topic and deserializes them from JSON.
- How do you handle deserialization errors in Kafka consumers?
- Explain the process of deserializing messages into custom objects.
- What is a consumer group in Kafka, and why is it important?
- Describe a scenario where multiple consumer groups are used for a single topic.
- How does Kafka ensure load balancing among consumers in a group?
- How do you send JSON data to a Kafka topic and ensure it is properly serialized?
- Describe the process of consuming JSON data from a Kafka topic and converting it to a usable format.
- Explain how you can work with CSV data in Kafka, including serialization and deserialization.
- Write a Kafka producer code snippet that sends CSV data to a topic.
- Write a Kafka consumer code snippet that reads and processes CSV data from a topic.

𝗚𝗲𝘁 𝘁𝗵𝗲 𝗙𝘂𝗹𝗹 𝗜𝗻𝘁𝗲𝗿𝘃𝗶𝗲𝘄 𝗽𝗿𝗲𝗽 𝗸𝗶𝘁 𝗳𝗼𝗿 𝗗𝗮𝘁𝗮 𝗘𝗻𝗴𝗶𝗻𝗲𝗲𝗿𝘀 𝗵𝗲𝗿𝗲 -
https://lnkd.in/gNH-trFm

================================


𝐒𝐩𝐫𝐢𝐧𝐠 𝐁𝐨𝐨𝐭 𝐈𝐧𝐭𝐞𝐫𝐯𝐢𝐞𝐰 𝐐𝐮𝐞𝐬𝐭𝐢𝐨𝐧𝐬 𝐟𝐨𝐫 𝐅𝐫𝐞𝐬𝐡𝐞𝐫𝐬:

1. What are the advantages of using Spring Boot?
2. What are the Spring Boot key components?
3. Why Spring Boot over Spring?
4. What is the starter dependency of the Spring boot module?
5. How does Spring Boot works?
6. What does the @SpringBootApplication annotation do internally?
7. What is the purpose of using @ComponentScan in the class files?
8. How does a Spring Boot application get started?
9. What are starter dependencies?
10. What is Spring Initializer?
11. What is Spring Boot CLI and what are its benefits?
12. What are the most common Spring Boot CLI commands?


𝐀𝐝𝐯𝐚𝐧𝐜𝐞𝐝 𝐒𝐩𝐫𝐢𝐧𝐠 𝐁𝐨𝐨𝐭 𝐐𝐮𝐞𝐬𝐭𝐢𝐨𝐧𝐬:

13. What Are the Basic Annotations that Spring Boot Offers?
14. What is Spring Boot dependency management?
15. Can we create a non-web application in Spring Boot?
16. Is it possible to change the port of the embedded Tomcat server in Spring Boot?
17. What is the default port of Tomcat in Spring Boot?
18. Can we override or replace the Embedded Tomcat server in Spring Boot?
19. Can we disable the default web server in the Spring Boot application?
20. How to disable a specific auto-configuration class?
21. Explain @RestController annotation in Spring Boot?
22. What is the difference between @RestController and @Controller in Spring Boot?
23. Describe the flow of HTTPS requests through the Spring Boot application?
24. What is the difference between RequestMapping and GetMapping?
25. What is the use of Profiles in Spring Boot?
26. What is Spring Actuator? What are its advantages?
27. How to enable Actuator in Spring Boot application?
28. What are the actuator-provided endpoints used for monitoring the Spring Boot application?
29. How to get the list of all the beans in your Spring Boot application?
30. How to check the environment properties in your Spring Boot application?
31. How to enable debugging log in the Spring Boot application?
32. Where do we define properties in the Spring Boot application?
33. What is Dependency Injection?
34. What is an IOC container? 


====================================

Sharing below the Spring boot JPA Roadmap and learning Resources:

0. Understanding of Spring boot JDBC 
 
1. JPA Architecture 
- Overview of JPA as a specification
- Components: EntityManager, EntityManagerFactory, and Persistence Context
- JPA’s role in the ORM ecosystem
- JPA life cycle and persistence contexts (transaction-scoped and extended)
- JPA provider (e.g., Hibernate) roles
 
2. JPA vs Hibernate vs JDBC 
- JPA as a specification vs Hibernate as an implementation
- Direct JDBC vs ORM (which one is fast)
 
3. Setup 
- Adding dependencies (Maven and Gradle)
- Configuring application.properties for database connection
- Initializing EntityManagerFactory and EntityManager
- Creating a Spring Boot project with JPA dependencies
 
4. In-memory DB, MySQL, and Hibernate Configuration
- Setting up an in-memory(H2) or MySql database 
- Hibernate configuration properties in application.properties
 
5. Mapping Classes to Tables
- Basics of @Entity and @Table annotations
- Mapping Java class fields to database columns
 
6. Entity Annotations and Lifecycle
- @Entity and its essential role in JPA
- Entity lifecycle states: transient, managed, detached, removed
- Callbacks with @PrePersist, @PostPersist, @PreUpdate, @PostUpdate
 
7. Annotations: 
- @Id for primary keys
- @GeneratedValue and ID generation strategies 
- @SequenceGenerator and @TableGenerator usage
- Column properties with @Column
- Table configurations with @Table
 
8. Basic CRUD Operations
- Creating CRUD repositories (CrudRepository, JpaRepository)
- Basic methods: save, findById, deleteById
 
9. Custom Queries
- Defining custom queries with method names
- Using @Query for JPQL queries
 
10. Criteria Queries
- Overview of the Criteria API
- Creating dynamic queries programmatically
- Named parameters in criteria queries
- Handling native queries with CriteriaBuilder
 
11. Transactions 

12. Relationships:
- Overview of association types in JPA
 One-to-One: Mapping @OneToOne unidirectional and bidirectional
One-to-Many: Using @OneToMany with mappedBy and cascade
Many-to-One: Configuring @ManyToOne
Many-to-Many: Using @ManyToMany with join tables
- Unidirectional vs. bidirectional mappings
 
13. Pagination and Sorting
- Using Pageable and PageRequest for pagination
- Sorting options (Sort class)
- Pagination strategies for large datasets
 
14. Audit Logging
- Using @CreatedDate and @LastModifiedDate
- @CreatedBy and @LastModifiedBy for user tracking
- Enabling JPA auditing in Spring Boot
 
15. DTO Projections
- Overview of DTO projections for read-only views
- Using @Query for DTO-based projections
 
16. Lazy vs. Eager Loading

17. Caching Levels (First and Second)

Learning Resource:
Youtube:
Spring boot playlist: https://lnkd.in/gz2A5ih2

============================
Kafka Interview Questions

𝗕𝗮𝘀𝗶𝗰 𝗟𝗲𝘃𝗲𝗹:

• What is Apache Kafka, and what are its core components?
• Explain the difference between a topic, partition, and segment.
• How does Kafka ensure message ordering?
• What is a consumer group in Kafka?
• What is Kafka's replication factor, and why is it important?

𝗜𝗻𝘁𝗲𝗿𝗺𝗲𝗱𝗶𝗮𝘁𝗲 𝗟𝗲𝘃𝗲𝗹:

• How does Kafka achieve fault tolerance?
• Explain Kafka's partitioning strategy and how it impacts performance.
• What is Kafka retention policy, and how does it work?
• Describe Kafka's consumer offset management.
• How can Kafka handle backpressure in real-time data processing?

𝗔𝗱𝘃𝗮𝗻𝗰𝗲𝗱 𝗟𝗲𝘃𝗲𝗹:

• Explain the concept of exactly-once semantics (EOS) in Kafka.
• How would you monitor and optimize Kafka performance in a production environment?
• Describe how Kafka handles leader election for partitions.
• What are the challenges of using Kafka in a multi-datacenter setup?
• How would you design a Kafka-based system to guarantee data consistency in the event of node failures?

𝗚𝗲𝘁 𝘁𝗵𝗲 𝗙𝘂𝗹𝗹 𝗜𝗻𝘁𝗲𝗿𝘃𝗶𝗲𝘄 𝗽𝗿𝗲𝗽 𝗸𝗶𝘁 𝗳𝗼𝗿 𝗗𝗮𝘁𝗮 𝗘𝗻𝗴𝗶𝗻𝗲𝗲𝗿𝘀 𝗵𝗲𝗿𝗲 -
https://lnkd.in/gNH-trFm

===========================

Java Interview Questions for Experienced Developers 

1. Differentiate between Volatile and Transient Variable in Java.
2. Differentiate between the Vector and ArrayList collections in Java.
3. How is Collection different from Collections in Java?
4. Discuss Dependency Injection and its significance in Object-Oriented Programming.
5. Can you write code for representing thread-safe singleton patterns in Java?
6. What is the importance of the hashCode() and equals() contract?
7. How is the classpath variable different from the path variable?
8. In a multi-threaded environment, can someone use a HashMap?
9. How would you help a colleague with less Java experience who has trouble serializing a class?
10. What is the best possible way to call the wait() method – using the if construct or the loop construct?
11. Can we use HashMap in a multi-threaded environment?
12. Distinguish between ArrayList and Vector in Java.
13. Briefly discuss the Factory Design pattern.
14. What will happen if you run 1.0/0.0?
15. Is it possible to override a method to throw a RuntimeException from throwing a NullPointerException in the parent class?
16. Is there any difference in defining or creating a String by using a String literal and using the new() operator?
17. Distinguish between String creation using the new() operator and String literal.
18. Write some important features of Java 8.
19. In the Singleton Pattern, what is the significance of double-checked locking?
20. Is it necessary to declare all immutable objects as final?
21. What do you know about the Factory Design Pattern in Java?
22. Is it possible to overload the main method?
23. Differentiate between Enumeration and Iterator.
24. Describe EnumSet.
25. Explain SerialVersionUID.
26. In hashing-based collections, state the default size of the load factor.
27. Differentiate between fail-safe and fail-fast.
28. Discuss IdentityHashMap.
29. Mention the benefits and limitations of Spring AOP.
30. What is the Properties class?
31. Mention 5 best practices used with threads.
32. When should one use the Flyweight pattern?
33. What is the difference between SAX and DOM parsers?
34. How does Garbage Collection work in Java?
35. What are weak references in Java?
36. How can you prevent Deadlock in Java?
37. Explain the Template Method design pattern.
38. What are Java Memory Leaks?
39. What are ThreadLocal variables?
40. How does Java handle stack and heap memory?


More interview questions 
1. https://lnkd.in/dMgxnstS
2. https://lnkd.in/dzqENJ8E
3. https://lnkd.in/dqnvHBGz
4. https://lnkd.in/dt8eEEqK
5. https://lnkd.in/dHU7G9n3

Summary of #Java 8,9,11,12,13,14,15,16,17,18,19 features.
All features in a single post. #share #like #follow

#Java 19 Features :
- Record Patterns (Preview)
- Linux/RISC-V Port
- Foreign Function & Memory API (preview)
- Virtual Threads (Preview)
- Vector API (Fourth Incubator)
- Structured Concurrency (Incubator)
- Pattern Matching for switch (Third Preview)

#Java 18 Features:
- UTF-8 by Default
- Simple Web Server
- Code Snippets in Java API Doc
- Reimplement Core Reflection with Method Handles
- Vector API
- Internet-Address Resolution SPI
- Foreign Function & Memory API
- Pattern Matching for switch

#Java 17 Features (Long Term Support) :
- Restore Always-Strict Floating-Point Semantics
- Enhanced Pseudo-Random Number Generators
- New macOS Rendering Pipeline
- macOS/AArch64 Port
- Deprecate the Applet API for Removal
- Strongly Encapsulate JDK Internals
- Pattern Matching for switch

#Java 16 Features:
- Vector API
- Enable C++14 Language Features
- Migrate from Mercurial to Git
- Migrate to GitHub
- Concurrent Thread-Stack Processing
- Unix-Domain Socket Channels
- Alpine Linux Port
- Elastic Metaspace
- Windows/AArch64 Port

#Java 15 Features
- Sealed Classes and Interfaces
- EdDSA Algorithm
- Hidden Classes
- Pattern Matching for instanceof
- Removed Nashorn JavaScript Engine
- Reimplement the Legacy DatagramSocket API
- Records (Second Preview)
- Text Blocks become a standard feature

#Java 14 Features
– Pattern Matching for instanceof
– Text Blocks
– Helpful NullPointerExceptions
– Records
– Switch Expressions
– Packaging Tool
– NUMA-Aware Memory Allocation for G1
– JFR Event Streaming
– Non-Volatile Mapped Byte Buffers
– Remove the Pack200 Tools and API

#Java 13 Features:
– Text Blocks (Preview)
– Switch Expressions Enhancements (Preview)
– Reimplement the Legacy Socket API
– Dynamic CDS Archive
– ZGC: Uncommit Unused Memory
– FileSystems.newFileSystem() Method
– DOM and SAX Factories with Namespace Support

#Java 12 Features:
- Collectors.teeing() in Stream API
- String API Changes
- Files.mismatch(Path, Path)
- Compact Number Formatting
- Support for Unicode 11
- Switch Expressions (Preview)

#Java 11 Features (Long Term Support):
- HTTP Client API
- Launch Single-File Programs Without Compilation
- String API Changes
- Collection.toArray(IntFunction)
- Files.readString() and Files.writeString()
- Optional.isEmpty()

#Java 9 Features:
- Java platform module system
- Interface Private Methods
- HTTP 2 Client
- JShell
- Platform and JVM Logging
- Process API Updates
- Collection API Updates
- Improvements in Stream API
- Multi-release JAR Files
- @Deprecated Tag Changes
- Stack Walking

#Java 8 Features (Long Term Support):
- Lambda expression
- Stream API
- Functional interface
- Default and static methods
- Optional class
- Nashorn – JavaScript runtime engine
- Unsigned Integer Arithmetic
- Repeating annotations
- New Date and Time API

=======================

1️⃣ What is the difference between Java 8’s Optional and traditional null checks?
2️⃣ Explain the purpose of functional interfaces in Java.
3️⃣ What is the difference between Stream.forEach() and Collection.forEach()?
4️⃣ How does the CompletableFuture class improve asynchronous programming?
5️⃣ What are default and static methods in interfaces?
6️⃣ How does the var keyword work in Java 10?
7️⃣ What are records in Java, and how do they simplify data classes?
8️⃣ What is the sealed keyword in Java, and how does it enhance inheritance?
9️⃣ How does the Pattern Matching feature improve instanceof checks?
🔟 What are the improvements in garbage collection in Java 11+?
👉 Stay tuned for Day 6: JVM & Performance Optimization!

